/*
本题要求实现一种数字加密方法。首先固定一个加密用正整数A，对任一正整数B，将其每1位数字与A的对应位置上的数字进行以下运算：
对奇数位，对应位的数字相加后对13取余――这里用J代表10、Q代表11、K代表12；
对偶数位，用B的数字减去A的数字，若结果为负数，则再加10。这里令个位为第1位。
输入格式：
输入在一行中依次给出A和B，均为不超过100位的正整数，其间以空格分隔。
输出格式：
在一行中输出加密后的结果。
输入样例：
1234567 368782971

输出样例：
3695Q8118
*/


#include <iostream>
#include <string>

using namespace std;

int main()
{
	string A, B;
	cin >> A >> B;
	string C;
	int ib;
	ib= B.length() - 1;
	for (int i = A.length() - 1; i >= 0 && ib>=0; i--)
	{
		if (i % 2 == 0)//奇数
		{
			int tmp;
			
			tmp = (A[i] - '0' + B[ib] - '0')%13;
			
			if (tmp < 10)
				C = to_string(tmp) +C;
			else if (tmp == 10)
				C = "J"+ C;
			else if (tmp == 11)
				C = "Q"+ C;
			else if (tmp == 12)
				C = "K" + C;
		}
		else
		{
			int tmp;
			tmp = B[ib] - '0' - A[i] + '0';

		
			while (tmp <= 0)
				tmp += 10;
			
			C = to_string(tmp) + C;
		}
		ib--;
	}
	ib++;
	if (ib > 0)
		C = B.substr(0, ib) + C;

	cout << C << endl;
	return 0;
}